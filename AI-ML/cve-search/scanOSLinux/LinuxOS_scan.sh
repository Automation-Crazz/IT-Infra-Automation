#!/bin/bash
# Linux System Security Scan Script - ASORP v2.3.1
# Standalone script for generating a JSON system report.
# To be run on the target Linux machine.
# Output JSON should be uploaded to the ASORP application.

echo "Starting Linux system security scan (ASORP v2.3.1)..."
# set -x # Uncomment for detailed script debugging

# --- Pre-requisite Check ---
if ! command -v jq &> /dev/null; then
    echo "ERROR: jq is not installed. jq is required to process and generate the JSON report."
    echo "Please install jq (e.g., 'sudo apt-get install jq' or 'sudo yum install jq') and try again."
    exit 1
fi

# --- Configuration ---
APP_NAME="ASORP_Scan"
TIMESTAMP=$(date -Iseconds)
HOSTNAME_VAL=$(hostname -f 2>/dev/null || hostname)
HOSTNAME_FN_SAFE=$(echo "$HOSTNAME_VAL" | sed 's/[^a-zA-Z0-9_-]/_/g' | cut -c -50) # Limit length for filename
SCAN_DIR_NAME="${APP_NAME}_${HOSTNAME_FN_SAFE}_$(date +%Y%m%d_%H%M%S)"

SCAN_OUTPUT_BASE_USER_DIR="$HOME/.${APP_NAME}_Reports" # Hidden directory in home
SCAN_OUTPUT_BASE_TMP_DIR="/tmp/${APP_NAME}_Reports"
FINAL_SCAN_OUTPUT_DIR=""

# Attempt to create report directory
if mkdir -p "$SCAN_OUTPUT_BASE_USER_DIR/$SCAN_DIR_NAME" 2>/dev/null; then
    FINAL_SCAN_OUTPUT_DIR="$SCAN_OUTPUT_BASE_USER_DIR/$SCAN_DIR_NAME"
elif mkdir -p "$SCAN_OUTPUT_BASE_TMP_DIR/$SCAN_DIR_NAME" 2>/dev/null; then
    FINAL_SCAN_OUTPUT_DIR="$SCAN_OUTPUT_BASE_TMP_DIR/$SCAN_DIR_NAME"
else
    echo "ERROR: Could not create report directory in '$SCAN_OUTPUT_BASE_USER_DIR' or '$SCAN_OUTPUT_BASE_TMP_DIR'. Exiting."
    exit 1
fi

OUTPUT_FILE="$FINAL_SCAN_OUTPUT_DIR/linux_scan_report_${HOSTNAME_FN_SAFE}.json"

# --- Initialize JSON Report ---
cat > "$OUTPUT_FILE" << EOF
{
  "scanHeader": {
    "timestamp": "$TIMESTAMP", "scanVersion": "2.3.1", "appName": "$APP_NAME",
    "hostname": "$HOSTNAME_VAL", "scanType": "linux_system_scan_script"
  },
  "osInfo": {}, "hardwareInfo": {},
  "networkInfo": { "interfaces": [], "routes": [], "dnsServers": [], "openPorts": [], "portSummary": "N/A" },
  "securityInfo": {}, "processes": [], "servicesSystemd": [],
  "installedPackages": { "packageManager": "unknown", "packages": [] },
  "installed_software": [],
  "usersAndGroups": { "users": [], "groupsSample": [] },
  "cronJobs": { "systemCronSample": [], "userCronSample": [] },
  "logSummary": { "authLogSample": "N/A", "syslogSample": "N/A" }
}
EOF
echo "INFO: Initial JSON report structure created: $OUTPUT_FILE"

# --- Helper Function for Robust JSON Update ---
update_json_data() {
    local json_path="$1" # e.g., ".osInfo"
    local new_json_data="$2"
    local temp_file
    temp_file=$(mktemp --suffix=.json)

    if ! echo "$new_json_data" | jq -e . > /dev/null 2>&1; then
        echo "ERROR: Invalid JSON data provided for path '$json_path'. Update SKIPPED."
        echo "Problematic data snippet: $(echo "$new_json_data" | head -c 200)"
        rm -f "$temp_file"
        return 1
    fi

    local path_array_str
    path_array_str=$(echo "$json_path" | sed 's/^\.//' | jq -R 'split(".")') # Remove leading dot for split

    if jq --argjson new_data "$new_json_data" --argjson path_arr "$path_array_str" \
        'setpath($path_arr; $new_data)' "$OUTPUT_FILE" > "$temp_file"; then
        if [ -s "$temp_file" ]; then
            mv "$temp_file" "$OUTPUT_FILE"
            echo "INFO: Successfully updated '$json_path' in report."
        else
            echo "ERROR: jq produced an empty file for path '$json_path'. Update ABORTED."
            rm -f "$temp_file"
            return 1
        fi
    else
        echo "ERROR: Failed to update JSON for path '$json_path' using jq."
        echo "Attempted data snippet: $(echo "$new_json_data" | head -c 200)"
        rm -f "$temp_file"
        return 1
    fi
    return 0
}

# --- Data Collection Functions (must echo valid JSON strings/arrays) ---
get_os_info() {
    local distro kernel arch uptime
    distro=$( (lsb_release -ds || cat /etc/*release 2>/dev/null | grep PRETTY_NAME | cut -d'=' -f2 | tr -d '"' || echo "Unknown") 2>/dev/null || echo "Unknown")
    kernel=$(uname -r 2>/dev/null || echo "Unknown")
    arch=$(uname -m 2>/dev/null || echo "Unknown")
    uptime=$( (uptime -p || uptime) 2>/dev/null || echo "Unknown")
    jq -n --arg d "$distro" --arg k "$kernel" --arg a "$arch" --arg u "$uptime" \
      '{{distribution: $d, kernel: $k, architecture: $a, uptime: $u}}' || echo "{{}}"
}

get_hardware_info() {
    local cpu mem disks
    cpu=$( (grep 'model name' /proc/cpuinfo | uniq | cut -d: -f2 | xargs) 2>/dev/null || echo "N/A")
    mem=$(free -b 2>/dev/null | awk 'NR==2 {{printf "{{\\"total_bytes\\": %s, \\"used_bytes\\": %s, \\"free_bytes\\": %s, \\"available_bytes\\": %s}}", $2, $3, $4, $7}}' || echo "{{}}")
    disks=$(df -B1 --output=source,target,fstype,size,used,avail,pcent 2>/dev/null | awk 'NR>1 {{printf "%s{{\\"device\\": \\"%s\\", \\"mountpoint\\": \\"%s\\", \\"fstype\\": \\"%s\\", \\"total_bytes\\": %s, \\"used_bytes\\": %s, \\"available_bytes\\": %s, \\"percent_used\\": \\"%s\\"}}", (NR==2 ? "" : ","), $1, $2, $3, $4, $5, $6, $7}}' | jq -sc '.' || echo "[]")
    jq -n --arg c "$cpu" --argjson m "$mem" --argjson d "$disks" \
      '{{cpuModel: $c, memory: $m, diskPartitions: $d}}' || echo "{{}}"
}

get_network_interfaces() { ip -j addr 2>/dev/null || echo "[]"; }
get_network_routes() { ip -j route 2>/dev/null || echo "[]"; }
get_dns_servers() { (grep "^nameserver" /etc/resolv.conf 2>/dev/null | awk '{{print $2}}' | jq -Rsc '. | split("\n") | map(select(. != ""))') || echo "[]"; }

get_open_ports() {
    local cmd_output
    if command -v ss &>/dev/null; then
        cmd_output=$(ss -tulnp 2>/dev/null)
    elif command -v netstat &>/dev/null; then
        cmd_output=$(netstat -tulnp 2>/dev/null)
    else
        echo "[]"; return
    fi

    echo "$cmd_output" | awk '
    BEGIN {{ print "[" ; sep = "" }}
    /Proto|State|Local Address/ {{next}}
    /LISTEN/ && ( $1 ~ /^tcp/ || $1 ~ /^udp/ ) {{
        print sep

        protocol = $1
        local_address_full = $4
        process_info_str = "N/A"

        if ($0 ~ /users:\(\((".*",pid=[0-9]+)/) {{
            match($0, /users:\(\("([^"]+)",pid=([0-9]+)/, arr)
            if (arr[1] && arr[2]) {{
                prg_name = arr[1]; gsub(/\\"/,"\\\\\\"", prg_name);
                process_info_str = sprintf("%s (pid:%s)", prg_name, arr[2])
            }}
        }} else {{
            if (NF >= 7 && $NF ~ /[0-9]+\//) {{
                 temp_proc_info = $NF; gsub(/\\"/,"\\\\\\"", temp_proc_info);
                 process_info_str = temp_proc_info
            }} else if (NF >= 6 && $(NF-1) ~ /[0-9]+\//) {{
                 temp_proc_info = $(NF-1); gsub(/\\"/,"\\\\\\"", temp_proc_info);
                 process_info_str = temp_proc_info
            }}
        }}

        split(local_address_full, addr_parts, ":")
        port_val_str = addr_parts[length(addr_parts)]
        address_val = ""
        for (k_idx=1; k_idx < length(addr_parts); k_idx++) {{
            address_val = address_val (k_idx > 1 ? ":" : "") addr_parts[k_idx]
        }}
        if (address_val == "" || address_val == "*" || address_val == "0.0.0.0" || address_val == "[::]") {{
            address_val = (protocol ~ /6$/ ? "::" : "0.0.0.0")
        }}
        if (! (port_val_str ~ /^[0-9]+$/)) {{ port_val_str = "0"; }}


        printf "{{\\"protocol\\":\\"%s\\", \\"local_address\\":\\"%s\\", \\"local_port\\":%s, \\"process_info\\":\\"%s\\"}}", \
               protocol, address_val, port_val_str, process_info_str
        sep = ","
    }}
    END {{ print "]" }}' | jq -c '.' 2>/dev/null || echo "[]"
}


get_security_info() {
    local fw_status_str selinux_sestatus_str selinux_getenforce_str sudo_powerful_count_val failed_logins_json last_logins_json
    fw_status_str="Unknown"
    if command -v ufw &>/dev/null; then fw_status_str=$(ufw status verbose 2>/dev/null | head -n 5);
    elif command -v firewall-cmd &>/dev/null; then fw_status_str=$( (firewall-cmd --state && firewall-cmd --list-all --timeout=3s) 2>/dev/null | head -n 10);
    elif command -v iptables &>/dev/null; then fw_status_str=$(iptables -L -n -v --line-numbers 2>/dev/null | head -n 15);
    else fw_status_str="Not determined (no known firewall tool found)"; fi
    [[ -z "$fw_status_str" ]] && fw_status_str="Error fetching or empty"
    fw_status_json=$(echo "$fw_status_str" | jq -Rsc 'split("\n") | map(select(length > 0))' 2>/dev/null || echo "[]")

    selinux_sestatus_str=$(sestatus 2>/dev/null | grep "SELinux status:" | awk '{{print $NF}}' || echo "N/A (sestatus error or not enabled)")
    selinux_getenforce_str=$(getenforce 2>/dev/null || echo "N/A")
    sudo_powerful_count_val=0
    if [ -r /etc/sudoers ]; then sudo_powerful_count_val=$(grep -vE '^\s*#|^\s*$' /etc/sudoers /etc/sudoers.d/* 2>/dev/null | grep -cP 'ALL\s*=\s*\(ALL(:ALL)?\)\s*(NOPASSWD:)?\s*ALL' || echo 0); fi
    failed_logins_json=$(lastb 2>/dev/null | head -n 10 | jq -Rsc 'split("\n") | map(select(length>0))' || echo "[]")
    last_logins_json=$(last -n 10 2>/dev/null | jq -Rsc 'split("\n") | map(select(length>0))' || echo "[]")

    jq -n \
      --argjson fw "$fw_status_json" \
      --arg se_s "$selinux_sestatus_str" \
      --arg ge_s "$selinux_getenforce_str" \
      --argjson sc "$sudo_powerful_count_val" \
      --argjson fl "$failed_logins_json" \
      --argjson ll "$last_logins_json" \
      '{{firewallStatusSummary: $fw, selinuxSestatus: $se_s, selinuxGetenforce: $ge_s, powerfulSudoersCount: $sc, failedLoginsSample: $fl, lastLoginsSample: $ll}}' || echo "{{}}"
}

get_running_processes() {
    ps -axo user:20,pid,ppid,pcpu,pmem,rss,vsz,stat,start_time,etime,cmd --no-headers --sort=-pmem,-pcpu | head -n 75 | \
    awk 'BEGIN{print "[" ; sep = ""}
        {
            print sep;
            user = $1; pid = $2; ppid = $3; cpu_percent = $4; mem_percent = $5;
            rss_bytes = $6*1024; vsz_bytes = $7*1024; status = $8; start_time = $9; elapsed_time = $10;
            command_str = ""; for(i_cmd=11;i_cmd<=NF;i_cmd++) command_str = command_str $i_cmd (i_cmd==NF?"":" ");
            gsub(/\\"/,"\\\\\\"",command_str);
            printf "{{\\"user\\":\\"%s\\",\\"pid\\":%s,\\"ppid\\":%s,\\"cpu_percent\\":%s,\\"mem_percent\\":%s,\\"rss_bytes\\":%s,\\"vsz_bytes\\":%s,\\"status\\":\\"%s\\",\\"start_time\\":\\"%s\\",\\"elapsed_time\\":\\"%s\\",\\"command\\":\\"%s\\"}}",
            user,pid,ppid,cpu_percent,mem_percent,rss_bytes,vsz_bytes,status,start_time,elapsed_time,command_str;
            sep = ","
        } END{print "]"}' | jq -c '.' 2>/dev/null || echo "[]"
}

get_systemd_services() {
    if command -v systemctl &>/dev/null; then
        systemctl list-units --type=service --state=running --no-legend --plain | head -n 50 | \
        awk 'BEGIN{print "[" ; sep = ""}
            {
                print sep;
                name=$1; gsub(/\.service$/,"",name); gsub(/\\"/,"\\\\\\"",name);
                load=$2; gsub(/\\"/,"\\\\\\"",load);
                active=$3; gsub(/\\"/,"\\\\\\"",active);
                sub_state=$4; gsub(/\\"/,"\\\\\\"",sub_state);
                desc_str = ""; for(i_desc=5;i_desc<=NF;i_desc++) desc_str = desc_str $i_desc (i_desc==NF?"":" ");
                gsub(/\\"/,"\\\\\\"",desc_str);
                printf "{{\\"name\\":\\"%s\\",\\"load\\":\\"%s\\",\\"active\\":\\"%s\\",\\"sub_state\\":\\"%s\\",\\"description\\":\\"%s\\"}}",
                name,load,active,sub_state,desc_str;
                sep = ","
            } END{print "]"}' | jq -c '.' 2>/dev/null || echo "[]"
    else
        echo "[]"
    fi
}

get_installed_packages_and_software_list() {
    local pkg_mgr="unknown"
    local packages_json="[]"
    local software_list_json="[]"
    local raw_pkg_data=""

    if command -v dpkg &>/dev/null; then
        pkg_mgr="dpkg"
        raw_pkg_data=$(dpkg-query -W -f='${Package}\t${Version}\t${Architecture}\t${Description}\n' 2>/dev/null | \
                       grep -E 'installed$' | head -n 250)
    elif command -v rpm &>/dev/null; then
        pkg_mgr="rpm"
        raw_pkg_data=$(rpm -qa --qf '%{NAME}\t%{VERSION}-%{RELEASE}\t%{ARCH}\t%{SUMMARY}\n' 2>/dev/null | \
                       head -n 250)
    fi

    if [ -n "$raw_pkg_data" ]; then
        packages_json=$(echo "$raw_pkg_data" | \
        awk -F'\t' 'BEGIN{print "[" ; sep = ""}
            {
                print sep;
                name=$1; gsub(/\\"/,"\\\\\\"",name);
                ver=$2; gsub(/\\"/,"\\\\\\"",ver);
                arch=$3; gsub(/\\"/,"\\\\\\"",arch);
                desc=$4; gsub(/\\"/,"\\\\\\"",desc);
                printf "{{\\"name\\":\\"%s\\",\\"version\\":\\"%s\\",\\"architecture\\":\\"%s\\",\\"description\\":\\"%s\\"}}", name,ver,arch,desc;
                sep = ","
            } END{print "]"}' | jq -c '.' 2>/dev/null || echo "[]")
        software_list_json=$(echo "$packages_json" | jq '[.[] | {{name: .name, version: .version, publisher: .architecture, description: .description}}]' 2>/dev/null || echo "[]")
    fi
    local llm_summary_names
    llm_summary_names=$(echo "$packages_json" | jq -r 'map(.name) | .[:20] | join(", ")' 2>/dev/null || echo "N/A")

    jq -n --arg pm "$pkg_mgr" --argjson pkgs "$packages_json" \
          --argjson sl "$software_list_json" --arg lsn "$llm_summary_names" \
      '{{packageManager: $pm, packages: $pkgs, softwareList: $sl, installedSoftwareNamesForLLM: $lsn }}' || echo '{{ "packageManager": "error", "packages": [], "softwareList": [], "installedSoftwareNamesForLLM": "error" }}'
}

get_users() {
    (awk -F':' '$3 >= 1000 && $3 != 65534 {{printf "%s{{\\"username\\":\\"%s\\",\\"uid\\":%s,\\"gid\\":%s,\\"home\\":\\"%s\\",\\"shell\\":\\"%s\\"}}", (c++ == 0 ? "" : ","), $1,$3,$4,$6,$7}}' /etc/passwd ) | jq -sc '.' 2>/dev/null || echo "[]"
}

# --- Main Execution Flow ---
( update_json_data ".osInfo" "$(get_os_info)" ) || echo "WARNING: OS Information collection faced an issue."
( update_json_data ".hardwareInfo" "$(get_hardware_info)" ) || echo "WARNING: Hardware Information collection faced an issue."
( update_json_data ".networkInfo.interfaces" "$(get_network_interfaces)" ) || echo "WARNING: Network Interfaces collection faced an issue."
( update_json_data ".networkInfo.routes" "$(get_network_routes)" ) || echo "WARNING: Network Routes collection faced an issue."
( update_json_data ".networkInfo.dnsServers" "$(get_dns_servers)" ) || echo "WARNING: DNS Servers collection faced an issue."

OPEN_PORTS_RAW_JSON=$(get_open_ports)
( update_json_data ".networkInfo.openPorts" "$OPEN_PORTS_RAW_JSON" ) || echo "WARNING: Open Ports collection faced an issue."
PORT_SUMMARY_STR=$(echo "$OPEN_PORTS_RAW_JSON" | jq -r 'if type == "array" and length > 0 then (map("\(.local_port)/\(.protocol | sub("tcp6";"tcp") | sub("udp6";"udp") | sub("unix";"local"))") | unique | .[:25] | join(", ")) else "None identified" end' 2>/dev/null || echo "Error processing ports for summary")
( update_json_data ".networkInfo.portSummary" "\"Open ports: $PORT_SUMMARY_STR\"" ) || echo "WARNING: Port Summary update faced an issue."

( update_json_data ".securityInfo" "$(get_security_info)" ) || echo "WARNING: Security Information collection faced an issue."
( update_json_data ".processes" "$(get_running_processes)" ) || echo "WARNING: Running Processes collection faced an issue."
( update_json_data ".servicesSystemd" "$(get_systemd_services)" ) || echo "WARNING: Systemd Services collection faced an issue."

PACKAGES_AND_SOFTWARE_JSON=$(get_installed_packages_and_software_list)
( update_json_data ".installedPackages" "$(echo "$PACKAGES_AND_SOFTWARE_JSON" | jq '.')" ) || echo "WARNING: Installed Packages collection faced an issue."
( update_json_data ".installed_software" "$(echo "$PACKAGES_AND_SOFTWARE_JSON" | jq '.softwareList')" ) || echo "WARNING: Derived 'installed_software' list update faced an issue."

( update_json_data ".usersAndGroups.users" "$(get_users)" ) || echo "WARNING: User Information collection faced an issue."

# --- Finalization ---
echo "INFO: Scan data collection complete. Finalizing JSON report..."
if jq -e '.' "$OUTPUT_FILE" > /dev/null 2>&1; then
    echo "SUCCESS: JSON report at '$OUTPUT_FILE' is valid."
else
    echo "CRITICAL ERROR: Final JSON report '$OUTPUT_FILE' is invalid. Please check for errors above or inspect the file."
fi

chmod 644 "$OUTPUT_FILE"
echo "INFO: Linux system security scan finished."
echo "Report saved to: $OUTPUT_FILE"
echo "Please upload this JSON file to the ASORP application for analysis."

exit 0