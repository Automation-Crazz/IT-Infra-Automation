import requests
import pandas as pd
import time
import re
import json
import gzip
import io
from datetime import datetime, timezone
from collections import defaultdict
import os

# Linux components to monitor
LINUX_COMPONENTS = {
    "Linux Kernel": [
        "kernel", "system call", "syscall", "vmlinuz", "initrd", "KVM", "bpf", "eBPF",
        "seccomp", "cgroup", "namespace", "module", "driver", "ext4", "XFS", "Btrfs",
        "SELinux", "AppArmor", "netfilter", "iptables", "nftables", "io_uring"
    ],
    "System Libraries": [
        "glibc", "GNU C Library", "libc", "openssl", "gnutls", "nss", "pam", "libssl",
        "libcrypto", "zlib", "bzip2", "xz", "lz4", "zstd", "libpng", "libjpeg", "libtiff",
        "libxml2", "libxslt", "sqlite", "expat", "libarchive", "libcurl"
    ],
    "Core Utilities": [
        "coreutils", "util-linux", "procps", "psmisc", "findutils", "grep", "sed", "awk",
        "gzip", "tar", "cpio", "bash", "dash", "zsh", "fish", "sudo", "su", "auditd",
        "cron", "at", "systemd", "syslog", "rsyslog", "journald", "logrotate"
    ],
    "Networking Services": [
        "sshd", "ssh", "OpenSSH", "telnet", "ftp", "vsftpd", "tftp", "dnsmasq", "bind",
        "unbound", "dhcp", "dhclient", "httpd", "apache", "nginx", "lighttpd", "squid",
        "postfix", "sendmail", "exim", "dovecot", "nfs", "samba", "smbd", "nmbd",
        "iptables", "nftables", "firewalld", "ufw", "ipsec", "strongswan", "openvpn",
        "wireguard", "tcpdump", "wireshark", "netcat", "socat"
    ],
    "Package Management": [
        "dpkg", "apt", "apt-get", "rpm", "yum", "dnf", "zypper", "pacman", "snap",
        "flatpak", "dpkg", "apt", "rpm", "yum", "dnf", "zypper", "pacman"
    ],
    "Security Tools": [
        "sudo", "su", "polkit", "pkexec", "auditd", "apparmor", "selinux", "firejail",
        "bubblewrap", "gpg", "gnupg", "opensc", "pam", "libpam", "fprintd", "sssd",
        "oath", "yubico", "clamav", "rkhunter", "chkrootkit", "lynis", "tripwire"
    ],
    "Virtualization/Containers": [
        "docker", "containerd", "runc", "cri-o", "podman", "lxc", "lxd", "kvm", "qemu",
        "libvirt", "virsh", "virt-manager", "cloud-init", "multipass", "systemd-nspawn"
    ],
    "Red Hat Enterprise Linux": [
        "rhel", "red hat", "redhat", "centos", "fedora", "selinux", "yum", "dnf",
        "rpm", "firewalld", "cockpit", "satellite", "ansible", "openshift"
    ],
    "Ubuntu": [
        "ubuntu", "debian", "apt", "dpkg", "snap", "landscape", "maas", "lxd", "upstart",
        "netplan", "ufw", "apparmor", "launchpad", "canonical", "do-release-upgrade"
    ]
}

# Well-known Linux ports
LINUX_PORTS = {
    "20": "FTP Data",
    "21": "FTP Control",
    "22": "SSH",
    "23": "Telnet",
    "25": "SMTP",
    "53": "DNS",
    "67": "DHCP Server",
    "68": "DHCP Client",
    "69": "TFTP",
    "80": "HTTP",
    "88": "Kerberos",
    "110": "POP3",
    "111": "RPC",
    "123": "NTP",
    "135": "MSRPC",
    "139": "NetBIOS",
    "143": "IMAP",
    "161": "SNMP",
    "162": "SNMP Trap",
    "389": "LDAP",
    "443": "HTTPS",
    "445": "SMB",
    "465": "SMTPS",
    "514": "Syslog",
    "515": "LPD",
    "587": "SMTP Submission",
    "631": "IPP",
    "636": "LDAPS",
    "993": "IMAPS",
    "995": "POP3S",
    "2049": "NFS",
    "3306": "MySQL",
    "3389": "RDP",
    "5432": "PostgreSQL",
    "5900": "VNC",
    "5938": "TeamViewer",
    "6000": "X11",
    "6379": "Redis",
    "8080": "HTTP Proxy",
    "8443": "HTTPS Alt",
    "9090": "Cockpit",
    "27017": "MongoDB"
}

# CISA Known Exploited Vulnerabilities
CISA_KEV_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"

# NVD Data Feeds (no API key needed)
NVD_BASE_URL = "https://nvd.nist.gov/feeds/json/cve/1.1"
YEARS = [str(year) for year in range(2020, 2025)]  # 2020 to 2024

def fetch_cisa_kev():
    """Fetch CISA's Known Exploited Vulnerabilities catalog"""
    print("Fetching CISA KEV catalog...")
    try:
        response = requests.get(CISA_KEV_URL, timeout=15)
        response.raise_for_status()
        return response.json().get('vulnerabilities', [])
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to fetch CISA KEV: {str(e)}")
        return []

def get_linux_mitigation(component, cve_id, cisa_kev):
    """Generate mitigation guidance for Linux components"""
    # Check if vulnerability is in CISA KEV
    in_kev = any(kev['cveID'] == cve_id for kev in cisa_kev)
    kev_note = "üî¥ CISA Known Exploited Vulnerability. Patch immediately!" if in_kev else ""
    
    # Vendor-specific guidance
    if "Kernel" in component:
        return f"{kev_note}\n- Update kernel: sudo apt install --only-upgrade linux-image-generic\n" \
               "- Reboot system after update\n- Limit exposed kernel features via sysctl"
    
    elif "Red Hat" in component:
        return f"{kev_note}\n- Update: sudo yum update\n- Apply security patches: sudo yum update --security\n" \
               "- Check advisories: https://access.redhat.com/security/updates"
    
    elif "Ubuntu" in component:
        return f"{kev_note}\n- Update: sudo apt update && sudo apt upgrade\n" \
               "- Apply security updates: sudo unattended-upgrade\n" \
               "- Check advisories: https://ubuntu.com/security"
    
    elif "OpenSSH" in component or "SSH" in component:
        return f"{kev_note}\n- Update OpenSSH: sudo apt install --only-upgrade openssh-server\n" \
               "- Restrict SSH access in /etc/ssh/sshd_config\n" \
               "- Use key-based authentication only"
    
    elif "Samba" in component:
        return f"{kev_note}\n- Update Samba: sudo apt install --only-upgrade samba\n" \
               "- Restrict SMB protocols in /etc/samba/smb.conf\n" \
               "- Isolate Samba services on private network"
    
    elif "Docker" in component or "Container" in component:
        return f"{kev_note}\n- Update Docker: sudo apt install --only-upgrade docker-ce\n" \
               "- Run containers with least privileges\n" \
               "- Scan images for vulnerabilities"
    
    # General guidance for other components
    return f"{kev_note}\n- Update package: sudo apt install --only-upgrade {component.split()[0].lower()}\n" \
           "- Restart affected services\n" \
           "- Monitor system logs for suspicious activity"

def identify_affected_components(description):
    """Identify Linux components mentioned in vulnerability description"""
    components = set()
    ports = set()
    
    try:
        # Check for component keywords with word boundaries
        for component, keywords in LINUX_COMPONENTS.items():
            for keyword in keywords:
                pattern = r'\b' + re.escape(keyword) + r'\b'
                if re.search(pattern, description, re.IGNORECASE):
                    components.add(component)
        
        # Check for well-known ports by service name
        for port, service in LINUX_PORTS.items():
            pattern = r'\b' + re.escape(service) + r'\b'
            if re.search(pattern, description, re.IGNORECASE):
                ports.add(port)
        
        # Find port numbers mentioned in description
        port_matches = re.findall(r'port\s+(\d{1,5})\b', description, re.IGNORECASE)
        for port in port_matches:
            if 1 <= int(port) <= 65535:
                ports.add(port)
                
        # Also check for :port format (e.g., :80, :443)
        colon_ports = re.findall(r':(\d{1,5})\b', description)
        for port in colon_ports:
            if 1 <= int(port) <= 65535:
                ports.add(port)
                
    except Exception as e:
        print(f"‚ö†Ô∏è Component identification error: {str(e)}")
    
    # Convert to sorted lists
    return sorted(components), sorted(ports)

def download_nvd_feed(year):
    """Download and parse NVD feed for a specific year"""
    url = f"{NVD_BASE_URL}/nvdcve-1.1-{year}.json.gz"
    print(f"Downloading NVD feed for {year}...")
    
    try:
        response = requests.get(url, stream=True, timeout=120)
        response.raise_for_status()
        
        with gzip.GzipFile(fileobj=io.BytesIO(response.content)) as gz_file:
            return json.load(gz_file)
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to download {year} feed: {str(e)}")
        return None

def process_cve_item(item, cisa_kev):
    """Process a single CVE item and extract Linux-related vulnerabilities"""
    try:
        cve = item['cve']
        cve_id = cve['CVE_data_meta']['ID']
        
        # Get description
        description = ""
        for desc_data in cve['description']['description_data']:
            if desc_data['lang'] == 'en':
                description = desc_data['value']
                break
        
        # Check if it's Linux-related
        linux_keywords = ['linux', 'ubuntu', 'rhel', 'red hat', 'debian', 'centos', 'fedora']
        if not any(keyword in description.lower() for keyword in linux_keywords):
            return None
        
        # Identify affected components and ports
        affected_components, affected_ports = identify_affected_components(description)
        
        # Use first component or fallback to generic
        primary_component = affected_components[0] if affected_components else "Linux System"
        
        # Get mitigation guidance
        mitigation = get_linux_mitigation(primary_component, cve_id, cisa_kev)
        
        # Get distribution info
        distributions = []
        for distro in ['Red Hat Enterprise Linux', 'Ubuntu']:
            if distro in LINUX_COMPONENTS:
                if any(keyword in description.lower() for keyword in LINUX_COMPONENTS[distro]):
                    distributions.append(distro)
        
        # Get published date
        published = item.get('publishedDate', '')
        
        return {
            'CVE': cve_id,
            'Published': published,
            'Vendor': "NVD",
            'CVSS': get_cvss_score(item),
            'Distributions': "; ".join(distributions) if distributions else "N/A",
            'Components': "; ".join(affected_components) if affected_components else "N/A",
            'Ports': "; ".join(affected_ports) if affected_ports else "N/A",
            'PrimaryComponent': primary_component,
            'Description': description,
            'Mitigation': mitigation,
            'LastUpdated': datetime.now(timezone.utc).strftime('%Y-%m-%d')
        }
    except Exception as e:
        print(f"‚ö†Ô∏è Error processing {cve_id}: {str(e)}")
        return None

def get_cvss_score(item):
    """Safely extract CVSS score from CVE item"""
    try:
        # Check for CVSS v3 first
        if 'impact' in item and 'baseMetricV3' in item['impact']:
            return item['impact']['baseMetricV3']['cvssV3']['baseScore']
        
        # Fallback to CVSS v2
        if 'impact' in item and 'baseMetricV2' in item['impact']:
            return item['impact']['baseMetricV2']['cvssV2']['baseScore']
    except:
        pass
    return "N/A"

def main():
    start_time = time.time()
    print("Starting Linux vulnerability data extraction")
    print(f"Processing years: {', '.join(YEARS)}")
    
    # Fetch CISA KEV catalog
    cisa_kev = fetch_cisa_kev()
    print(f"Loaded {len(cisa_kev)} CISA KEV records")
    
    # Collect all vulnerabilities
    all_vulns = []
    vuln_count = 0
    
    for year in YEARS:
        data = download_nvd_feed(year)
        if not data or 'CVE_Items' not in data:
            continue
            
        print(f"Processing {len(data['CVE_Items'])} CVEs for {year}")
        
        for item in data['CVE_Items']:
            vuln = process_cve_item(item, cisa_kev)
            if vuln:
                all_vulns.append(vuln)
                vuln_count += 1
                
                # Progress tracking
                if vuln_count % 1000 == 0:
                    elapsed = time.time() - start_time
                    print(f"Processed {vuln_count} Linux vulnerabilities | "
                          f"Elapsed: {elapsed//60:.0f}m {elapsed%60:.0f}s")
    
    # Save results
    if all_vulns:
        df = pd.DataFrame(all_vulns)
        filename = f"linux_vulnerabilities_{len(df)}_{datetime.now(timezone.utc).strftime('%Y%m%d')}.csv"
        df.to_csv(filename, index=False)
        
        print("\n" + "="*60)
        print(f"‚úÖ Saved {len(df)} Linux vulnerabilities to {filename}")
        print(f"Time Period: {YEARS[0]} to {YEARS[-1]}")
        
        # Top components analysis
        if not df.empty:
            top_components = df['PrimaryComponent'].value_counts().head(10).to_dict()
            distro_counts = df['Distributions'].value_counts().to_dict()
        else:
            top_components = {}
            distro_counts = {}
            
        print(f"Top Components: {top_components}")
        print(f"Distribution: {distro_counts}")
        print("="*60)
    else:
        print("No Linux vulnerabilities found!")

if __name__ == "__main__":
    main()