import requests
import pandas as pd
import time
import re
import json
from datetime import datetime

# Comprehensive list of Windows Server ports (0-1023) with service mappings
WELL_KNOWN_PORTS = {
    7: 'Echo', 19: 'Chargen', 20: 'FTP Data', 21: 'FTP Control', 22: 'SSH', 
    23: 'Telnet', 25: 'SMTP', 42: 'WINS', 43: 'Whois', 49: 'TACACS', 
    53: 'DNS', 67: 'DHCP Server', 68: 'DHCP Client', 69: 'TFTP', 70: 'Gopher',
    79: 'Finger', 80: 'HTTP', 88: 'Kerberos', 102: 'MS Exchange', 110: 'POP3',
    111: 'RPC', 113: 'Ident', 119: 'NNTP', 123: 'NTP', 135: 'MSRPC',
    137: 'NetBIOS-NS', 138: 'NetBIOS-DGM', 139: 'NetBIOS-SSN', 143: 'IMAP',
    161: 'SNMP', 162: 'SNMP Trap', 177: 'XDMCP', 179: 'BGP', 194: 'IRC',
    201: 'AppleTalk', 264: 'BGMP', 318: 'TSP', 381: 'HP Openview', 383: 'HP Openview',
    389: 'LDAP', 411: 'Direct Connect', 412: 'Direct Connect', 427: 'SLP',
    443: 'HTTPS', 445: 'SMB', 464: 'Kerberos Password', 465: 'SMTPS',
    500: 'IPSec', 502: 'Modbus', 512: 'Rexec', 513: 'Rlogin', 514: 'Syslog',
    515: 'LPD', 520: 'RIP', 521: 'RIPng', 540: 'UUCP', 543: 'Klogin',
    544: 'Kshell', 546: 'DHCPv6 Client', 547: 'DHCPv6 Server', 548: 'AFP',
    554: 'RTSP', 563: 'NNTPS', 587: 'SMTP Submission', 591: 'FileMaker',
    593: 'MS DCOM', 636: 'LDAPS', 639: 'MSDP', 646: 'LDP', 647: 'DHCP Failover',
    648: 'RRP', 652: 'DTCP', 654: 'AODV', 665: 'sun-dr', 666: 'Doom',
    674: 'ACAP', 691: 'MS Exchange Routing', 692: 'Hyperwave-ISP', 694: 'Heartbeat',
    695: 'IEEE-MMS-SSL', 698: 'OLSR', 699: 'Access Network', 700: 'EPP',
    701: 'LMP', 702: 'IRIS', 706: 'SILC', 711: 'TDP', 712: 'TBRPF',
    720: 'SMQP', 729: 'IBM NetView', 730: 'IBM NetView', 731: 'IBM NetView',
    740: 'netcp', 741: 'netgw', 742: 'netrcs', 744: 'Flexible License Manager',
    747: 'Fujitsu Device Control', 748: 'Fujitsu Device Control', 749: 'Kerberos Admin',
    750: 'Kerberos Version', 751: 'Kerberos Password', 752: 'Kerberos Password',
    753: 'Kerberos Registry', 754: 'Kerberos Registry', 758: 'nlogin', 759: 'con',
    760: 'ns', 761: 'rxe', 762: 'quotad', 763: 'cycleserv', 764: 'omserv',
    765: 'webster', 767: 'phone', 769: 'vid', 770: 'cadlock', 771: 'rtip',
    772: 'cycleserv', 773: 'submit', 774: 'rpasswd', 775: 'entomb', 776: 'wpages',
    777: 'Multiling HTTP', 780: 'wpgs', 781: 'HP Performance', 782: 'HP Performance',
    783: 'HP Performance', 800: 'MDBS Daemon', 801: 'Device', 808: 'CCProxy',
    829: 'CMP', 830: 'NETCONF', 831: 'NETCONF', 832: 'NETCONF', 833: 'NETCONF',
    843: 'Adobe Flash', 847: 'DHCP Failover', 848: 'GDOI', 853: 'DNS-over-TLS',
    860: 'iSCSI', 861: 'OWAMP-Control', 862: 'TWAMP-Control', 873: 'rsync',
    888: 'AccessBuilder', 897: 'Brocade SMI', 898: 'SMA Reg', 902: 'VMware Auth',
    903: 'VMware Update', 953: 'rndc', 981: 'Checkpoint VPN', 989: 'FTPS Data',
    990: 'FTPS Control', 991: 'Netnews', 992: 'TelnetS', 993: 'IMAPS',
    995: 'POP3S', 1000: 'Cadlock', 1023: 'Reserved'
}

# Windows Server roles, features, and services
WINDOWS_COMPONENTS = {
    # Server Roles
    'active directory': {'type': 'role', 'ports': [53, 88, 123, 135, 137, 138, 139, 389, 445, 464, 636]},
    'dhcp server': {'type': 'role', 'ports': [67, 68]},
    'dns server': {'type': 'role', 'ports': [53]},
    'file services': {'type': 'role', 'ports': [137, 138, 139, 445]},
    'print services': {'type': 'role', 'ports': [137, 138, 139, 445, 515]},
    'web server': {'type': 'role', 'ports': [80, 443]},
    'remote desktop services': {'type': 'role', 'ports': [3389]},
    'hyper-v': {'type': 'role', 'ports': [135, 137, 138, 139, 445, 2179, 5358]},
    'windows deployment services': {'type': 'role', 'ports': [67, 68, 69, 4011]},
    
    # Features
    '.net framework': {'type': 'feature', 'ports': []},
    'bitlocker': {'type': 'feature', 'ports': []},
    'branchcache': {'type': 'feature', 'ports': [80, 443]},
    'data deduplication': {'type': 'feature', 'ports': []},
    'directaccess': {'type': 'feature', 'ports': [443, 500, 4500]},
    'failover clustering': {'type': 'feature', 'ports': [3343]},
    'group policy': {'type': 'feature', 'ports': [135, 137, 138, 139, 445]},
    'iis': {'type': 'feature', 'ports': [80, 443]},
    'network policy server': {'type': 'feature', 'ports': [1645, 1646, 1812, 1813]},
    'remote server administration tools': {'type': 'feature', 'ports': [135]},
    'storage replica': {'type': 'feature', 'ports': [445, 9389]},
    'windows defender': {'type': 'feature', 'ports': [80, 443]},
    'windows server backup': {'type': 'feature', 'ports': [135, 445]},
    'wsl': {'type': 'feature', 'ports': []},
    
    # Services/Processes
    'background intelligent transfer': {'type': 'service', 'ports': [443]},
    'credential guard': {'type': 'service', 'ports': []},
    'distributed transaction coordinator': {'type': 'service', 'ports': [135]},
    'iis admin service': {'type': 'service', 'ports': [80, 443]},
    'kerberos key distribution center': {'type': 'service', 'ports': [88]},
    'message queuing': {'type': 'service', 'ports': [1801, 2101, 2103, 2105]},
    'netlogon': {'type': 'service', 'ports': [135, 139, 445]},
    'nt lm security support provider': {'type': 'service', 'ports': [135, 139, 445]},
    'remote procedure call': {'type': 'service', 'ports': [135]},
    'server': {'type': 'service', 'ports': [139, 445]},
    'spooler': {'type': 'service', 'ports': [135, 139, 445]},
    'task scheduler': {'type': 'service', 'ports': [135, 445]},
    'windows event log': {'type': 'service', 'ports': []},
    'windows management instrumentation': {'type': 'service', 'ports': [135]},
    'windows remote management': {'type': 'service', 'ports': [5985, 5986]},
    'windows time': {'type': 'service', 'ports': [123]},
    'workstation': {'type': 'service', 'ports': [139, 445]}
}


# CISA Known Exploited Vulnerabilities
CISA_KEV_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"

def fetch_cisa_kev():
    """Fetch CISA's Known Exploited Vulnerabilities catalog"""
    print("Fetching CISA KEV catalog...")
    try:
        response = requests.get(CISA_KEV_URL, timeout=15)
        response.raise_for_status()
        return response.json().get('vulnerabilities', [])
    except Exception as e:
        print(f"⚠️ Failed to fetch CISA KEV: {str(e)}")
        return []

def get_generic_mitigation(component, cve_id, cisa_kev):
    """Generate generic mitigation based on component type and CISA data"""
    # Check if CISA has specific guidance
    for vuln in cisa_kev:
        if vuln.get('cveID') == cve_id:
            return vuln.get('requiredAction', 'Apply updates per vendor instructions')
    
    # Component-specific guidance
    mitigations = {
        'active directory': [
            "Apply strict LDAP signing/channel binding",
            "Monitor for anomalous DC replication",
            "Restrict domain admin privileges"
        ],
        'iis': [
            "Disable unused IIS modules",
            "Implement request filtering",
            "Validate all inputs"
        ],
        'smb': [
            "Disable SMBv1",
            "Enforce SMB signing",
            "Restrict access to port 445"
        ],
        'rdp': [
            "Enable Network Level Authentication",
            "Limit RDP access via firewall rules",
            "Use VPN for remote access"
        ],
        'windows defender': [
            "Keep antivirus signatures updated",
            "Enable cloud-based protection",
            "Regularly scan systems"
        ],
        'hyper-v': [
            "Isolate host management network",
            "Enable shielded VMs",
            "Apply latest integration components"
        ],
        'default': [
            "Apply security updates immediately",
            "Restrict affected component access",
            "Monitor for exploitation attempts",
            "Review system logs for anomalies"
        ]
    }
    
    return "\n".join(mitigations.get(component.lower(), mitigations['default']))

def analyze_description(description):
    """Extract ports, features, services, and components from description"""
    try:
        if not description:
            return [], [], [], []
            
        desc_lower = description.lower()
        ports = set()
        features = set()
        services = set()
        components = set()
        
        # 1. Detect port numbers (0-65535)
        port_matches = re.findall(r'\b(\d{1,4}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])\b', desc_lower)
        for port_str in port_matches:
            try:
                port = int(port_str)
                if 0 <= port <= 1023:  # Only consider well-known ports
                    ports.add(port)
            except ValueError:
                continue
        
        # 2. Detect components and map to ports
        for comp_name, comp_data in WINDOWS_COMPONENTS.items():
            if comp_name in desc_lower:
                # Add to appropriate category
                if comp_data['type'] == 'feature':
                    features.add(comp_name)
                elif comp_data['type'] == 'service':
                    services.add(comp_name)
                elif comp_data['type'] == 'role':
                    components.add(comp_name)
                
                # Add associated ports
                ports.update(comp_data['ports'])
        
        # 3. Detect port names (e.g., "SMB port")
        for port_num, port_name in WELL_KNOWN_PORTS.items():
            if port_name.lower() in desc_lower:
                ports.add(port_num)
        
        # 4. Special cases for common protocols
        protocol_mappings = {
            'rdp': 3389, 'smb': 445, 'winrm': 5985, 'ldap': 389, 
            'kerberos': 88, 'dns': 53, 'http': 80, 'https': 443
        }
        for protocol, port_num in protocol_mappings.items():
            if protocol in desc_lower:
                ports.add(port_num)
        
        return list(ports), list(features), list(services), list(components)
    except Exception as e:
        print(f"⚠️ Error in description analysis: {str(e)}")
        return [], [], [], []

def get_primary_component(desc):
    """Identify primary affected component"""
    try:
        if not desc:
            return "Windows Server Core"
            
        component_priority = [
            'active directory', 'group policy', 'hyper-v', 
            'smb', 'rdp', 'kerberos', 'netlogon',
            'iis', 'dns', 'dhcp', 'windows defender'
        ]
        
        for component in component_priority:
            if component in desc:
                return component.title()
    except:
        pass
    return "Windows Server Core"

def get_cvss_score(cve):
    """Safely extract CVSS score"""
    try:
        metrics = cve.get('metrics', {})
        if 'cvssMetricV3' in metrics:
            return metrics['cvssMetricV3'][0]['cvssData']['baseScore']
        elif 'cvssMetricV2' in metrics:
            return metrics['cvssMetricV2'][0]['cvssData']['baseScore']
    except (KeyError, IndexError, TypeError):
        pass
    return "N/A"

def parse_windows_cves(response, cisa_kev):
    """Extract Windows Server vulnerabilities with generic mitigation"""
    cve_list = []
    if not response or 'vulnerabilities' not in response:
        return cve_list
    
    for vuln in response.get('vulnerabilities', []):
        try:
            cve = vuln.get('cve', {})
            cve_id = cve.get('id', 'CVE-UNKNOWN')
            descriptions = cve.get('descriptions', [])
            description = descriptions[0].get('value', '') if descriptions else ''
            
            # Analyze description for ports/components
            ports, features, services, components = analyze_description(description)
            primary_component = get_primary_component(description.lower())
            
            # Generate generic mitigation
            mitigation = get_generic_mitigation(primary_component, cve_id, cisa_kev)
            
            cve_list.append({
                'CVE': cve_id,
                'Published': cve.get('published', 'N/A'),
                'Vendor': cve.get('sourceIdentifier', 'N/A'),
                'CVSS': get_cvss_score(cve),
                'Ports': ";".join(map(str, ports)) if ports else "N/A",
                'Components': primary_component,
                'Description': description,
                'Mitigation': mitigation,
                'LastUpdated': datetime.now().strftime('%Y-%m-%d')
            })
        except Exception as e:
            print(f"⚠️ Error processing CVE: {str(e)}")
    
    return cve_list

def fetch_nvd_batch(start_index, results_per_page):
    """Fetch a batch of vulnerabilities from NVD with error handling"""
    try:
        url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=Windows+Server&startIndex={start_index}&resultsPerPage={results_per_page}"
        headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"}
        response = requests.get(url, headers=headers, timeout=30)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"⚠️ NVD API error: {str(e)}")
        return None

def main():
    # Fetch CISA KEV catalog
    cisa_kev = fetch_cisa_kev()
    print(f"Loaded {len(cisa_kev)} CISA KEV records")
    
    # Vulnerability collection parameters
    all_cves = []
    total_cves = 10000
    results_per_page = 2000
    max_retries = 3
    
    print("\nStarting vulnerability collection...")
    start_time = time.time()
    
    for start_index in range(0, total_cves, results_per_page):
        retries = 0
        success = False
        batch_cves = []
        
        while retries < max_retries and not success:
            try:
                # Fetch from NVD
                data = fetch_nvd_batch(start_index, results_per_page)
                if not data:
                    raise ValueError("Empty API response")
                
                # Parse vulnerabilities
                batch_cves = parse_windows_cves(data, cisa_kev)
                all_cves.extend(batch_cves)
                success = True
                
                # Progress tracking
                elapsed = time.time() - start_time
                print(f"Processed {start_index+1}-{start_index+len(batch_cves)}: "
                      f"{len(batch_cves)} vulns | Total: {len(all_cves)} | "
                      f"Elapsed: {elapsed//60:.0f}m {elapsed%60:.0f}s")
                
            except Exception as e:
                retries += 1
                wait = 10 * retries
                print(f"Error: {e}. Retry {retries}/{max_retries} in {wait}s")
                time.sleep(wait)
        
        if not success:
            print(f"Failed batch: {start_index}")
            # Skip to next batch
            continue
        
        # Check if we have enough vulnerabilities
        if len(all_cves) >= total_cves:
            print(f"\nReached target of {total_cves} vulnerabilities")
            break
            
        # NVD rate limit compliance
        time.sleep(6)
    
    # Save results
    if all_cves:
        df = pd.DataFrame(all_cves)
        filename = f"windows_server_vulns_{len(df)}_mitigation_{datetime.now().strftime('%Y%m%d')}.csv"
        df.to_csv(filename, index=False)
        
        print("\n" + "="*60)
        print(f"✅ Saved {len(df)} vulnerabilities to {filename}")
        print(f"Top Components: {df['Components'].value_counts().head(5).to_dict()}")
        print(f"Time range: {df['Published'].min()} to {df['Published'].max()}")
        print("="*60)
    else:
        print("No vulnerabilities found!")

if __name__ == "__main__":
    main()