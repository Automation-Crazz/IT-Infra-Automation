import requests
import pandas as pd
import time
import re
from datetime import datetime

# List of Windows services and processes to monitor
WINDOWS_SERVICES_PROCESSES = [
    # Core Windows Services
    'svchost.exe', 'lsass.exe', 'wininit.exe', 'services.exe', 'lsm.exe',
    'spoolsv.exe', 'taskhost.exe', 'dllhost.exe', 'csrss.exe', 'winlogon.exe',
    'smss.exe', 'explorer.exe', 'wmiprvse.exe', 'msdtc.exe', 'dwm.exe',
    
    # Service Host Processes
    'svchost', 'service host', 'service_host',
    
    # Critical Services
    'Background Intelligent Transfer Service', 'BITS',
    'Cryptographic Services', 'CryptSvc',
    'DHCP Client', 'Dhcp',
    'DNS Client', 'Dnscache',
    'Event Log', 'EventLog',
    'Group Policy Client', 'gpsvc',
    'Network Connections', 'Netman',
    'Plug and Play', 'PlugPlay',
    'Print Spooler', 'Spooler',
    'Remote Procedure Call', 'RpcSs',
    'Security Accounts Manager', 'SamSs',
    'Server', 'LanmanServer',
    'Task Scheduler', 'Schedule',
    'Windows Audio', 'AudioSrv',
    'Windows Defender', 'WinDefend',
    'Windows Firewall', 'MpsSvc',
    'Windows Management Instrumentation', 'Winmgmt',
    'Windows Update', 'wuauserv',
    
    # Additional Processes
    'ctfmon.exe', 'rundll32.exe', 'msiexec.exe', 'conhost.exe', 'SearchIndexer.exe',
    'WmiPrvSE.exe', 'TrustedInstaller.exe', 'iexplore.exe', 'chrome.exe', 'firefox.exe'
]

# CISA Known Exploited Vulnerabilities
CISA_KEV_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"

def fetch_cisa_kev():
    """Fetch CISA's Known Exploited Vulnerabilities catalog"""
    print("Fetching CISA KEV catalog...")
    try:
        response = requests.get(CISA_KEV_URL, timeout=15)
        response.raise_for_status()
        return response.json().get('vulnerabilities', [])
    except Exception as e:
        print(f"⚠️ Failed to fetch CISA KEV: {str(e)}")
        return []

def get_service_mitigation(service_name, cve_id, cisa_kev):
    """Generate mitigation guidance for specific services"""
    # Check CISA recommendations first
    for vuln in cisa_kev:
        if vuln.get('cveID') == cve_id:
            return vuln.get('requiredAction', 'Apply vendor updates immediately')
    
    # Service-specific guidance
    mitigations = {
        'print spooler': [
            "Disable Print Spooler service if not needed",
            "Restrict access to spooler directories",
            "Apply latest security updates"
        ],
        'windows update': [
            "Ensure automatic updates are enabled",
            "Verify update integrity with hashes",
            "Monitor for unusual update behavior"
        ],
        'windows defender': [
            "Keep antivirus signatures updated",
            "Enable tamper protection",
            "Run regular full system scans"
        ],
        'remote procedure call': [
            "Restrict RPC access via firewall",
            "Disable unnecessary RPC endpoints",
            "Enable RPC authentication"
        ],
        'task scheduler': [
            "Audit scheduled tasks regularly",
            "Restrict task creation privileges",
            "Monitor task execution logs"
        ],
        'default': [
            "Stop and disable the service if not required",
            "Apply all security updates for the service",
            "Restrict service permissions using ACLs",
            "Monitor service execution and resource usage"
        ]
    }
    
    service_lower = service_name.lower()
    for key in mitigations:
        if key in service_lower:
            return "\n".join(mitigations[key])
    
    return "\n".join(mitigations['default'])

def identify_affected_services(description):
    """Identify Windows services/processes mentioned in vulnerability description"""
    if not description:
        return []
    
    desc_lower = description.lower()
    affected = []
    
    # Check for service/process names
    for service in WINDOWS_SERVICES_PROCESSES:
        service_lower = service.lower()
        if service_lower in desc_lower:
            # Prioritize exact matches
            if re.search(rf'\b{re.escape(service_lower)}\b', desc_lower):
                affected.append(service)
    
    # Special case for service abbreviations
    service_mappings = {
        'bits': 'Background Intelligent Transfer Service',
        'cryptsvc': 'Cryptographic Services',
        'dhcp': 'DHCP Client',
        'dnscache': 'DNS Client',
        'eventlog': 'Event Log',
        'gpsvc': 'Group Policy Client',
        'netman': 'Network Connections',
        'plugplay': 'Plug and Play',
        'spooler': 'Print Spooler',
        'rpcss': 'Remote Procedure Call',
        'sams': 'Security Accounts Manager',
        'lanmanserver': 'Server',
        'schedule': 'Task Scheduler',
        'audiosrv': 'Windows Audio',
        'windefend': 'Windows Defender',
        'mpssvc': 'Windows Firewall',
        'winmgmt': 'Windows Management Instrumentation',
        'wuauserv': 'Windows Update'
    }
    
    for abbr, full_name in service_mappings.items():
        if abbr in desc_lower and full_name not in affected:
            affected.append(full_name)
    
    return list(set(affected))

def get_cvss_score(cve):
    """Safely extract CVSS score"""
    try:
        metrics = cve.get('metrics', {})
        if 'cvssMetricV3' in metrics:
            return metrics['cvssMetricV3'][0]['cvssData']['baseScore']
        elif 'cvssMetricV2' in metrics:
            return metrics['cvssMetricV2'][0]['cvssData']['baseScore']
    except (KeyError, IndexError, TypeError):
        pass
    return "N/A"

def fetch_nvd_batch(start_index, results_per_page=2000):
    """Fetch vulnerabilities from NVD API"""
    try:
        url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=windows&startIndex={start_index}&resultsPerPage={results_per_page}"
        headers = {"User-Agent": "Windows-Service-Vuln-Scanner/1.0"}
        response = requests.get(url, headers=headers, timeout=30)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"⚠️ NVD API error: {str(e)}")
        return None

def process_vulnerabilities(data, cisa_kev):
    """Process vulnerabilities and extract service-related ones"""
    vuln_list = []
    if not data or 'vulnerabilities' not in data:
        return vuln_list
    
    for item in data['vulnerabilities']:
        try:
            cve = item.get('cve', {})
            cve_id = cve.get('id', '')
            descriptions = cve.get('descriptions', [])
            description = descriptions[0].get('value', '') if descriptions else ''
            
            # Identify affected services/processes
            affected_services = identify_affected_services(description)
            if not affected_services:
                continue
                
            # Get primary service for mitigation
            primary_service = affected_services[0] if affected_services else "Windows Service"
            
            # Get mitigation guidance
            mitigation = get_service_mitigation(primary_service, cve_id, cisa_kev)
            
            vuln_list.append({
                'CVE': cve_id,
                'Published': cve.get('published', 'N/A'),
                'Vendor': cve.get('sourceIdentifier', 'N/A'),
                'CVSS': get_cvss_score(cve),
                'AffectedServices': "; ".join(affected_services),
                'PrimaryService': primary_service,
                'Description': description,
                'Mitigation': mitigation,
                'LastUpdated': datetime.now().strftime('%Y-%m-%d')
            })
        except Exception as e:
            print(f"⚠️ Error processing {cve_id}: {str(e)}")
    
    return vuln_list

def main():
    # Fetch CISA KEV catalog
    cisa_kev = fetch_cisa_kev()
    print(f"Loaded {len(cisa_kev)} CISA KEV records")
    
    # Vulnerability collection parameters
    all_vulns = []
    target_count = 10000
    batch_size = 2000
    max_retries = 3
    
    print("\nStarting vulnerability collection for Windows services...")
    print(f"Monitoring {len(WINDOWS_SERVICES_PROCESSES)} services/processes")
    start_time = time.time()
    batch_count = 0
    
    while len(all_vulns) < target_count:
        batch_count += 1
        start_index = len(all_vulns)
        retries = 0
        success = False
        batch_vulns = []
        
        while retries < max_retries and not success:
            try:
                # Fetch batch from NVD
                data = fetch_nvd_batch(start_index, batch_size)
                if not data:
                    raise ValueError("Empty API response")
                
                # Process vulnerabilities
                batch_vulns = process_vulnerabilities(data, cisa_kev)
                all_vulns.extend(batch_vulns)
                success = True
                
                # Progress tracking
                elapsed = time.time() - start_time
                print(f"Batch {batch_count}: Processed {len(batch_vulns)} service vulns | "
                      f"Total: {len(all_vulns)}/{target_count} | "
                      f"Elapsed: {elapsed//60:.0f}m {elapsed%60:.0f}s")
                
            except Exception as e:
                retries += 1
                wait = 10 * retries
                print(f"Error: {e}. Retry {retries}/{max_retries} in {wait}s")
                time.sleep(wait)
        
        if not success:
            print(f"⚠️ Failed to process batch {batch_count}")
            if batch_count > 10:  # Prevent infinite loops
                break
        
        # Check if we've reached target
        if len(all_vulns) >= target_count:
            break
            
        # Respect NVD rate limits
        time.sleep(6)
    
    # Trim to target count
    final_vulns = all_vulns[:target_count]
    
    # Save results
    if final_vulns:
        df = pd.DataFrame(final_vulns)
        filename = f"windows_service_vulns_{len(df)}_{datetime.now().strftime('%Y%m%d')}.csv"
        df.to_csv(filename, index=False)
        
        print("\n" + "="*60)
        print(f"✅ Saved {len(df)} Windows service vulnerabilities to {filename}")
        print(f"Top Services: {df['PrimaryService'].value_counts().head(10).to_dict()}")
        print(f"Time Range: {df['Published'].min()} to {df['Published'].max()}")
        print("="*60)
    else:
        print("No service vulnerabilities found!")

if __name__ == "__main__":
    main()