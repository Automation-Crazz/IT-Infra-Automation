import requests
import csv
import time
import sys

# --- Configuration ---
# NOTE: The year is set to 2023 because 2025 data is not yet available.
#       Change this to 2024 or 2025 when the time comes.
YEAR = 2024
TARGET_OS_KEYWORDS = ["Windows 10", "Windows 11"]
MAX_RESULTS = 1000
OUTPUT_FILENAME = f"cve_dump_{YEAR}_windows.csv"

# --- NVD API Configuration ---
NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
# We fetch the max allowed per page to reduce the number of API calls
RESULTS_PER_PAGE = 2000

# --- CSV Column Headers ---
CSV_COLUMNS = [
    "CVE", "Description", "Product", "Vendor", 
    "CVSS", "References", "Published", "AffectedOS"
]

def get_cvss_score(cve_item):
    """Gracefully extracts the CVSS V3.1 base score, falling back to V3.0 then V2.0."""
    metrics = cve_item.get('metrics', {})
    if 'cvssMetricV31' in metrics:
        return metrics['cvssMetricV31'][0]['cvssData'].get('baseScore', 'N/A')
    if 'cvssMetricV30' in metrics:
        return metrics['cvssMetricV30'][0]['cvssData'].get('baseScore', 'N/A')
    if 'cvssMetricV2' in metrics:
        return metrics['cvssMetricV2'][0]['cvssData'].get('baseScore', 'N/A')
    return "N/A"

def get_product_vendor_info(cve_item):
    """
    Attempts to find a relevant product and vendor from CPE matches.
    Prioritizes Microsoft Windows entries.
    """
    if "configurations" in cve_item:
        for config in cve_item["configurations"]:
            for node in config.get("nodes", []):
                for cpe_match in node.get("cpeMatch", []):
                    cpe_uri = cpe_match.get("criteria", "")
                    if "microsoft" in cpe_uri and "windows" in cpe_uri:
                        parts = cpe_uri.split(":")
                        if len(parts) > 4:
                            vendor = parts[3].title()
                            product = parts[4].replace("_", " ").title()
                            return product, vendor
    return "N/A", "N/A"

def get_references(cve_item):
    """Extracts reference URLs and joins them into a single string."""
    refs = [ref['url'] for ref in cve_item.get('references', [])]
    return " | ".join(refs) if refs else "N/A"

def main():
    """Main function to fetch CVEs and write to CSV."""
    print("--- CVE Data Extractor ---")
    print(f"Target Year: {YEAR}")
    print(f"Target OS Keywords: {', '.join(TARGET_OS_KEYWORDS)}")
    print(f"Max Results: {MAX_RESULTS}")
    print("NOTE: NVD API does not allow filtering by keyword and date simultaneously.")
    print("Fetching all CVEs for the year and filtering locally.")
    print("-" * 35)

    matching_cves = []
    
    session = requests.Session()
    session.headers.update({'User-Agent': 'CVE Extractor Script'})
    
    start_index = 0
    
    # Loop to paginate through all results for the year
    while len(matching_cves) < MAX_RESULTS:
        params = {
            'pubStartDate': f'{YEAR}-01-01T00:00:00.000',
            'pubEndDate': f'{YEAR}-12-31T23:59:59.999',
            'resultsPerPage': RESULTS_PER_PAGE,
            'startIndex': start_index
        }
        
        try:
            print(f"[INFO] Fetching page of CVEs starting at index {start_index}...")
            response = session.get(NVD_API_URL, params=params)
            response.raise_for_status() # Raises an exception for bad status codes
            
        except requests.exceptions.RequestException as e:
            print(f"[ERROR] API request failed: {e}", file=sys.stderr)
            break

        data = response.json()
        vulnerabilities = data.get('vulnerabilities', [])
        total_results = data.get('totalResults', 0)

        if not vulnerabilities:
            print("[INFO] No more results found on the server.")
            break

        # Locally filter the downloaded results
        for item in vulnerabilities:
            cve = item['cve']
            description = cve['descriptions'][0]['value'].lower() if cve.get('descriptions') else ''
            
            # Check if any of our keywords are in the description
            found_keywords = [kw for kw in TARGET_OS_KEYWORDS if kw.lower() in description]
            
            if found_keywords:
                product, vendor = get_product_vendor_info(cve)
                
                cve_row = {
                    "CVE": cve.get('id', 'N/A'),
                    "Description": cve['descriptions'][0]['value'],
                    "Product": product,
                    "Vendor": vendor,
                    "CVSS": get_cvss_score(cve),
                    "References": get_references(cve),
                    "Published": cve.get('published', 'N/A'),
                    "AffectedOS": ", ".join(found_keywords) # List which keyword(s) matched
                }
                matching_cves.append(cve_row)
                
                if len(matching_cves) >= MAX_RESULTS:
                    break # Stop processing this page if we have enough results
        
        print(f"      > Processed {len(vulnerabilities)} CVEs, found {len(matching_cves)} matching so far.")

        # Prepare for next page
        start_index += RESULTS_PER_PAGE
        
        # Stop if we've processed all available results on the server
        if start_index >= total_results:
            print("[INFO] Reached the end of all available CVEs for the year.")
            break
            
        # --- IMPORTANT: Rate Limiting ---
        print("Waiting 6 seconds to respect API rate limits...")
        time.sleep(6)

    if not matching_cves:
        print("\n[WARNING] No CVE data was found for the specified criteria after searching all records for the year.")
        return

    # Truncate to exactly MAX_RESULTS if we overshot
    final_data = matching_cves[:MAX_RESULTS]

    print(f"\n[SUCCESS] Found {len(final_data)} total matching CVEs.")
    print(f"Writing data to '{OUTPUT_FILENAME}'...")

    try:
        with open(OUTPUT_FILENAME, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=CSV_COLUMNS)
            writer.writeheader()
            writer.writerows(final_data)
        print("CSV file created successfully!")
    except IOError as e:
        print(f"[ERROR] Could not write to file: {e}", file=sys.stderr)

if __name__ == "__main__":
    main()