import requests
import pandas as pd
import re
import time
import json
from datetime import datetime, timezone
import os
from bs4 import BeautifulSoup # For web scraping
from urllib.parse import urljoin, quote_plus # For URL construction

# Configuration
NVD_API_KEY = os.getenv('NVD_API_KEY', '')
VULNERS_API_KEY = os.getenv('VULNERS_API_KEY', '')
CISA_KEV_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
OUTPUT_FILE = f"vulnerability_report_{datetime.now(timezone.utc).strftime('%Y%m%d')}.csv"

# API request delays
NVD_REQUEST_DELAY = 0.7 if NVD_API_KEY else 6.1
VULNERS_REQUEST_DELAY = 1.1 if VULNERS_API_KEY else 6.1
CVEDETAILS_REQUEST_DELAY = 10 # Be very conservative with scraping

# Software list
SOFTWARE_LIST = [
    {
      "name": "Microsoft Windows Desktop Runtime - 8.0.11 (x64)",
      "version": "64.44.23253",
      "publisher": "Microsoft Corporation",
      "install_date": "20250130",
      "install_location": ""
    },
    # Example: A more common software for testing
    # {
    #   "name": "Apache HTTP Server",
    #   "version": "2.4.58", # A recent version
    #   "publisher": "Apache Software Foundation",
    #   "install_date": "20240101",
    #   "install_location": ""
    # }
]

# Ports
PORT_SUMMARY = "Open ports: 54546/TCP, 445/TCP, 49664/TCP, 49665/TCP, 5040/TCP, 49668/TCP, 49667/TCP, 135/TCP, 2869/TCP, 65138/TCP, 49826/TCP, 49669/TCP, 49666/TCP, 65208/TCP, 49667/TCP, 139/TCP, 49664/TCP, 1001/TCP, 49668/TCP, 135/TCP"
PORT_SERVICE_MAPPING = {
    445: "SMB", 135: "MSRPC", 139: "NetBIOS", 5040: "WinRM", 2869: "UPnP", 1001: "Web",
    49664: "RPC", 49665: "RPC", 49666: "RPC", 49667: "RPC", 49668: "RPC", 49669: "RPC",
    54546: "Unknown", 65138: "Unknown", 49826: "Unknown", 65208: "Unknown"
}

# --- Utility Functions (extract_ports, fetch_cisa_kev, get_mitigation) ---
# (These are the same as before, keeping them for brevity in this diff)
def extract_ports(port_summary):
    ports = [int(p) for p in re.findall(r'(\d+)/', port_summary) if p.isdigit()]
    return list(set(ports))

def fetch_cisa_kev():
    print("Fetching CISA KEV catalog...")
    try:
        response = requests.get(CISA_KEV_URL, timeout=15)
        response.raise_for_status()
        return response.json().get('vulnerabilities', [])
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to fetch CISA KEV: {str(e)}")
        return []

def get_mitigation(cve_id, cisa_kev):
    for vuln in cisa_kev:
        if vuln.get('cveID') == cve_id:
            return {'mitigation': vuln.get('requiredAction', 'Apply vendor updates'), 'exploited': 'Yes', 'due_date': vuln.get('dueDate', '')}
    return {'mitigation': 'Apply security updates. Restrict access.', 'exploited': 'Unknown', 'due_date': ''}

# --- NVD Query Function ---
def query_nvd(keyword, start_date="2015-01-01", end_date="2025-12-31"):
    base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    params = {
        'keywordSearch': keyword,
        'pubStartDate': f"{start_date}T00:00:00.000Z",
        'pubEndDate': f"{end_date}T23:59:59.999Z",
        'resultsPerPage': 200
    }
    headers = {"User-Agent": "VulnerabilityScanner/1.3", "Accept": "application/json"}
    if NVD_API_KEY:
        headers["apiKey"] = NVD_API_KEY
        if not hasattr(query_nvd, 'api_key_logged'):
            print(f"üîë NVD: Using API key. Request delay: {NVD_REQUEST_DELAY}s")
            query_nvd.api_key_logged = True
    else:
        if not hasattr(query_nvd, 'no_api_key_logged'):
            print(f"‚ö†Ô∏è NVD: No API key. Higher delay: {NVD_REQUEST_DELAY}s. Results limited/slow.")
            query_nvd.no_api_key_logged = True

    print(f"  NVD Query: \"{keyword}\"")
    try:
        response = requests.get(base_url, headers=headers, params=params, timeout=45)
        if response.status_code == 403:
            print(f"‚ö†Ô∏è NVD 403 Forbidden for '{keyword}'. Check API key or unauth. access limits.")
            return []
        if response.status_code == 404:
            print(f"‚ö†Ô∏è NVD 404 for '{keyword}'. URL: {response.url}. NVD may return 404 if keywordSearch yields no strong matches, especially without an API key.")
            return []
        if response.status_code == 429:
            retry_after = int(response.headers.get('Retry-After', 30 if not NVD_API_KEY else 5))
            print(f"‚ö†Ô∏è NVD Rate limited for '{keyword}'. Retrying after {retry_after}s")
            time.sleep(retry_after)
            return query_nvd(keyword, start_date, end_date)
        response.raise_for_status()
        return response.json().get('vulnerabilities', [])
    except requests.exceptions.JSONDecodeError as e:
        print(f"‚ö†Ô∏è NVD JSON Error for '{keyword}': {str(e)}. Response: {response.text[:200]}")
        return []
    except requests.exceptions.RequestException as e:
        print(f"‚ö†Ô∏è NVD Request Error for '{keyword}': {str(e)}")
        return []

# --- Vulners Query Function ---
def query_vulners(keyword):
    if not VULNERS_API_KEY:
        if not hasattr(query_vulners, 'no_api_key_warned'):
            print("‚ö†Ô∏è Vulners: VULNERS_API_KEY not set. Skipping. Get key: https://vulners.com/userinfo")
            query_vulners.no_api_key_warned = True
        return []

    base_url = "https://vulners.com/api/v3/search/lucene/"
    query = f'text:"{keyword}" AND type:cve'
    params = {'query': query, 'size': 50, 'apiKey': VULNERS_API_KEY}
    headers = {"User-Agent": "VulnerabilityScanner/1.3"}

    print(f"  Vulners Query: \"{keyword}\" (Lucene: {query})")
    try:
        response = requests.get(base_url, params=params, headers=headers, timeout=30)
        response.raise_for_status()
        data = response.json()
        if data.get('result') == 'error':
            print(f"‚ö†Ô∏è Vulners API Error for '{keyword}': {data.get('data', {}).get('error')}")
            return []
        return data.get('data', {}).get('search', [])
    except requests.exceptions.RequestException as e:
        print(f"‚ö†Ô∏è Vulners Request Error for '{keyword}': {str(e)}")
        return []

# --- CVEDetails.com Scraper (EXPERIMENTAL & VERY BASIC) ---
def query_cvedetails_product(software_name, software_version=""):
    """
    EXPERIMENTAL: Attempts to scrape cvedetails.com for a product.
    This is fragile, slow, and ethically questionable if used excessively.
    USE WITH CAUTION AND AT YOUR OWN RISK.
    """
    print(f"  CVEDetails Query (Experimental): \"{software_name} {software_version}\"")
    base_search_url = "https://www.cvedetails.com/google-search-results.php?q="
    search_term = f"{software_name} {software_version}".strip()
    if not search_term:
        return []

    search_url = base_search_url + quote_plus(search_term)
    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"} # Mimic a browser

    found_vulnerabilities = []
    try:
        print(f"    CVEDetails: Searching at {search_url}")
        response = requests.get(search_url, headers=headers, timeout=20)
        response.raise_for_status()
        soup = BeautifulSoup(response.content, 'lxml')

        # Try to find a link to a product page from Google Custom Search results
        product_page_url = None
        search_results_div = soup.find('div', class_='gsc-expansionArea') # Common container for results
        if search_results_div:
            links = search_results_div.find_all('a', class_='gs-title')
            for link in links:
                href = link.get('href')
                # Heuristic: product pages on cvedetails.com often look like this
                if href and '/product/' in href and 'cvedetails.com' in href:
                    # More specific check: does title somewhat match?
                    # This is very basic, could be improved with fuzzy matching
                    if software_name.lower().split()[0] in link.text.lower():
                        product_page_url = href
                        print(f"    CVEDetails: Found potential product page: {product_page_url}")
                        break
        
        if not product_page_url:
            print(f"    CVEDetails: Could not identify a clear product page for '{search_term}' from search results.")
            return []

        # Fetch the product page
        print(f"    CVEDetails: Fetching product page {product_page_url}")
        time.sleep(CVEDETAILS_REQUEST_DELAY / 2) # Pause before hitting product page
        product_response = requests.get(product_page_url, headers=headers, timeout=20)
        product_response.raise_for_status()
        product_soup = BeautifulSoup(product_response.content, 'lxml')

        # Look for the vulnerability table
        vuln_table = product_soup.find('table', {'id': 'vulnlisttable'})
        if not vuln_table:
            # Sometimes the table ID is different or structure changes
            vuln_table = product_soup.find('table', class_=['listtable', 'searchresults']) # Try common table classes
            if not vuln_table:
                 print(f"    CVEDetails: Vulnerability table not found on product page: {product_page_url}")
                 return []

        rows = vuln_table.find_all('tr')
        for row in rows[1:]: # Skip header row
            cols = row.find_all('td')
            if len(cols) > 3: # Basic check for a valid row structure
                cve_id_tag = cols[1].find('a') 
                cve_id = cve_id_tag.text.strip() if cve_id_tag else "N/A"
                
                # Heuristic: check if it looks like a CVE ID
                if not re.match(r"CVE-\d{4}-\d{4,}", cve_id):
                    continue

                # CVSS score is often in col[7] or col[9] depending on table version
                cvss_score = "N/A"
                # Try a few common column indices for CVSS
                for idx in [7, 9, 3]: # Col 3 for v2, 7 for v2 list, 9 for v3 list
                    if len(cols) > idx and cols[idx].text.strip():
                        try:
                            score_val = float(cols[idx].text.strip())
                            cvss_score = str(score_val)
                            break # Found a score
                        except ValueError:
                            continue # Not a float

                description_tag = cols[3] # This is usually a short summary or link to one
                description = description_tag.text.strip() if description_tag else "See CVEDetails page"
                if ">> Click Here <<" in description: # Common placeholder
                    description = "Summary on CVEDetails page (follow link)"


                # Published date is harder to get consistently from this table, usually not directly present.
                # We can use the CVE ID to get it from other sources if needed, or leave blank.
                published = "N/A (Check CVEDetails)"

                found_vulnerabilities.append({
                    'cve_id': cve_id,
                    'description': description,
                    'published': published, # Not easily available in this table view
                    'cvss_score': cvss_score,
                })
    except requests.exceptions.RequestException as e:
        print(f"‚ö†Ô∏è CVEDetails Request Error for '{search_term}': {str(e)}")
    except Exception as e:
        print(f"‚ö†Ô∏è CVEDetails Scraper Error for '{search_term}': {str(e)}")
    
    print(f"    CVEDetails: Found {len(found_vulnerabilities)} potential CVEs for '{search_term}'")
    return found_vulnerabilities


# --- Data Parsing and Processing Functions ---
def parse_vuln_data(vuln_item, source="NVD"):
    cve_id, description, published, cvss_score_str = "N/A", "No description", "N/A", "N/A"
    if source == "NVD":
        # ... (same as before)
        cve_data = vuln_item.get('cve', {})
        cve_id = cve_data.get('id', 'N/A')
        description = next((d['value'] for d in cve_data.get('descriptions', []) if d['lang'] == 'en'), "No description")
        published = cve_data.get('published', 'N/A')
        metrics = cve_data.get('metrics', {})
        if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
            cvss_score_str = str(metrics['cvssMetricV31'][0].get('cvssData', {}).get('baseScore', "N/A"))
        elif 'cvssMetricV30' in metrics and metrics['cvssMetricV30']:
            cvss_score_str = str(metrics['cvssMetricV30'][0].get('cvssData', {}).get('baseScore', "N/A"))
        elif 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
            cvss_score_str = str(metrics['cvssMetricV2'][0].get('cvssData', {}).get('baseScore', "N/A"))
    elif source == "Vulners":
        # ... (same as before)
        cve_id = vuln_item.get('_source', {}).get('id', 'N/A') 
        if not cve_id.startswith("CVE-"): 
            cve_ids_list = vuln_item.get('_source', {}).get('cvelist', [])
            if cve_ids_list: cve_id = cve_ids_list[0]
        description = vuln_item.get('_source', {}).get('title', vuln_item.get('_source', {}).get('description', "No description available"))
        published = vuln_item.get('_source', {}).get('published', 'N/A')
        cvss_data = vuln_item.get('_source', {}).get('cvss3', {}) or vuln_item.get('_source', {}).get('cvss', {})
        cvss_score_str = str(cvss_data.get('score', "N/A"))
    elif source == "CVEDetails": # Parsing data from our cvedetails scraper
        cve_id = vuln_item.get('cve_id', 'N/A')
        description = vuln_item.get('description', 'See CVEDetails page')
        published = vuln_item.get('published', 'N/A (Check CVEDetails)')
        cvss_score_str = str(vuln_item.get('cvss_score', "N/A"))

    return cve_id, description, published, cvss_score_str

def process_software_vulnerabilities(software, cisa_kev):
    results = []
    processed_cves = set()
    software_name = software.get('name', 'N/A')
    software_version = software.get('version', '')

    search_terms = list(dict.fromkeys([
        f"{software_name} {software_version}",
        software_name,
        re.sub(r'-\s*\d+(\.\d+)*.*$|\s*\d+(\.\d+)+.*$', '', software_name).strip()
    ]))

    for term in filter(None, search_terms):
        # NVD
        nvd_vulns = query_nvd(term)
        time.sleep(NVD_REQUEST_DELAY)
        for vuln_item in nvd_vulns:
            cve_id, desc, pub, cvss = parse_vuln_data(vuln_item, source="NVD")
            if cve_id == "N/A" or cve_id in processed_cves: continue
            processed_cves.add(cve_id)
            mit_info = get_mitigation(cve_id, cisa_kev)
            results.append({'Source': 'NVD', 'Type': 'Software', 'Component': software_name, 'Version': software_version,
                            'Publisher': software.get('publisher',''), 'CVE': cve_id, 'Published': pub, 'CVSS': cvss,
                            'Description': desc, 'Affected Ports': '', 'Mitigation': mit_info['mitigation'],
                            'Exploited': mit_info['exploited'], 'DueDate': mit_info['due_date'],
                            'LastUpdated': datetime.now(timezone.utc).strftime('%Y-%m-%d')})
        # Vulners
        vulners_vulns = query_vulners(term)
        time.sleep(VULNERS_REQUEST_DELAY)
        for vuln_item in vulners_vulns:
            cve_id, desc, pub, cvss = parse_vuln_data(vuln_item, source="Vulners")
            if cve_id == "N/A" or cve_id in processed_cves: continue
            processed_cves.add(cve_id)
            mit_info = get_mitigation(cve_id, cisa_kev)
            results.append({'Source': 'Vulners', 'Type': 'Software', 'Component': software_name, 'Version': software_version,
                            'Publisher': software.get('publisher',''), 'CVE': cve_id, 'Published': pub, 'CVSS': cvss,
                            'Description': desc, 'Affected Ports': '', 'Mitigation': mit_info['mitigation'],
                            'Exploited': mit_info['exploited'], 'DueDate': mit_info['due_date'],
                            'LastUpdated': datetime.now(timezone.utc).strftime('%Y-%m-%d')})
    
    # CVEDetails (using a more general software name for broader search)
    # Only try the primary software name for CVEDetails to avoid too many fragile requests
    cved_vulns = query_cvedetails_product(software_name, software_version) # Pass version too
    time.sleep(CVEDETAILS_REQUEST_DELAY)
    for vuln_item in cved_vulns:
        cve_id, desc, pub, cvss = parse_vuln_data(vuln_item, source="CVEDetails")
        if cve_id == "N/A" or cve_id in processed_cves: continue
        processed_cves.add(cve_id)
        mit_info = get_mitigation(cve_id, cisa_kev) # Use CISA KEV for mitigation based on CVE ID
        results.append({'Source': 'CVEDetails', 'Type': 'Software', 'Component': software_name, 'Version': software_version,
                        'Publisher': software.get('publisher',''), 'CVE': cve_id, 'Published': pub, 'CVSS': cvss,
                        'Description': desc, 'Affected Ports': '', 'Mitigation': mit_info['mitigation'],
                        'Exploited': mit_info['exploited'], 'DueDate': mit_info['due_date'],
                        'LastUpdated': datetime.now(timezone.utc).strftime('%Y-%m-%d')})
    return results

def process_port_vulnerabilities(port, cisa_kev):
    # For ports, NVD and Vulners are more appropriate. CVEDetails is product-focused.
    # So, we'll skip CVEDetails for port searches to simplify and reduce fragile requests.
    results = []
    processed_cves = set()
    service_name = PORT_SERVICE_MAPPING.get(port, f"Port {port}")

    search_terms = []
    if service_name != "Unknown" and service_name != f"Port {port}":
        search_terms.extend([f"{service_name} service", service_name])
    if port < 1024 or service_name == "Unknown" or service_name == f"Port {port}":
         search_terms.append(f"port {port}")
    if service_name == "MSRPC": search_terms.append("Microsoft RPC")
    
    unique_search_terms = list(dict.fromkeys(search_terms))

    for term in filter(None, unique_search_terms):
        # NVD
        nvd_vulns = query_nvd(term)
        time.sleep(NVD_REQUEST_DELAY)
        for vuln_item in nvd_vulns:
            cve_id, desc, pub, cvss = parse_vuln_data(vuln_item, source="NVD")
            if cve_id == "N/A" or cve_id in processed_cves: continue
            processed_cves.add(cve_id)
            mit_info = get_mitigation(cve_id, cisa_kev)
            results.append({'Source': 'NVD', 'Type': 'Port/Service', 'Component': service_name, 'Version': '', 'Publisher': '',
                            'CVE': cve_id, 'Published': pub, 'CVSS': cvss, 'Description': desc,
                            'Affected Ports': str(port), 'Mitigation': mit_info['mitigation'],
                            'Exploited': mit_info['exploited'], 'DueDate': mit_info['due_date'],
                            'LastUpdated': datetime.now(timezone.utc).strftime('%Y-%m-%d')})
        # Vulners
        vulners_vulns = query_vulners(term)
        time.sleep(VULNERS_REQUEST_DELAY)
        for vuln_item in vulners_vulns:
            cve_id, desc, pub, cvss = parse_vuln_data(vuln_item, source="Vulners")
            if cve_id == "N/A" or cve_id in processed_cves: continue
            processed_cves.add(cve_id)
            mit_info = get_mitigation(cve_id, cisa_kev)
            results.append({'Source': 'Vulners', 'Type': 'Port/Service', 'Component': service_name, 'Version': '', 'Publisher': '',
                            'CVE': cve_id, 'Published': pub, 'CVSS': cvss, 'Description': desc,
                            'Affected Ports': str(port), 'Mitigation': mit_info['mitigation'],
                            'Exploited': mit_info['exploited'], 'DueDate': mit_info['due_date'],
                            'LastUpdated': datetime.now(timezone.utc).strftime('%Y-%m-%d')})
    return results

# --- Main Function ---
def main():
    start_time = time.time()
    print(f"Starting vulnerability data collection ({datetime.now(timezone.utc).isoformat()})")
    print(f"Target date range for CVEs (NVD): 2015-01-01 to 2025-12-31")
    print("="*60)
    print("API KEY STATUS:")
    if not NVD_API_KEY: print("  ‚ÑπÔ∏è NVD: No API key. Performance severely impacted. Get key: https://nvd.nist.gov/developers/request-an-api-key")
    else: print("  üîë NVD: API Key detected.")
    if not VULNERS_API_KEY: print("  ‚ÑπÔ∏è Vulners: No API key. Vulners queries skipped. Get key: https://vulners.com/userinfo")
    else: print("  üîë Vulners: API Key detected.")
    print("  ‚ö†Ô∏è CVEDetails.com scraping is EXPERIMENTAL, slow, and may be unreliable/blocked.")
    print("="*60)

    ports = extract_ports(PORT_SUMMARY)
    print(f"Identified {len(ports)} unique ports: {sorted(ports)}")
    cisa_kev = fetch_cisa_kev()
    print(f"Loaded {len(cisa_kev)} CISA KEV records.")
    
    all_vulns = []
    TARGET_VULN_COUNT = 15000 # Adjust as needed

    print("\nProcessing software vulnerabilities...")
    for i, software in enumerate(SOFTWARE_LIST):
        print(f"Software {i+1}/{len(SOFTWARE_LIST)}: {software.get('name', 'N/A')} {software.get('version', 'N/A')}")
        vulns = process_software_vulnerabilities(software, cisa_kev)
        all_vulns.extend(vulns)
        print(f"    Collected {len(vulns)} vulns for this software. Total: {len(all_vulns)}")
        if TARGET_VULN_COUNT > 0 and len(all_vulns) >= TARGET_VULN_COUNT: break # Allow TARGET_VULN_COUNT=0 for no limit
    
    if (TARGET_VULN_COUNT == 0 or len(all_vulns) < TARGET_VULN_COUNT) and ports:
        print("\nProcessing port/service vulnerabilities...")
        for i, port in enumerate(sorted(ports)):
            print(f"Port {i+1}/{len(ports)}: {port} ({PORT_SERVICE_MAPPING.get(port, 'Unknown')})")
            vulns = process_port_vulnerabilities(port, cisa_kev)
            all_vulns.extend(vulns)
            print(f"    Collected {len(vulns)} vulns for this port. Total: {len(all_vulns)}")
            if TARGET_VULN_COUNT > 0 and len(all_vulns) >= TARGET_VULN_COUNT: break
    
    if not all_vulns:
        print("\n‚ö†Ô∏è No vulnerabilities found from any source. Ensure API keys are set and search terms are appropriate.")
        df = pd.DataFrame()
    else:
        df = pd.DataFrame(all_vulns)
        df = df.drop_duplicates(subset=['CVE', 'Component', 'Type', 'Source'], keep='first')
        df['CVSS_float'] = pd.to_numeric(df['CVSS'], errors='coerce').fillna(-1.0)
        df = df.sort_values(by=['Exploited', 'CVSS_float', 'Published'], ascending=[False, False, False])
        df = df.drop(columns=['CVSS_float'])

    df.to_csv(OUTPUT_FILE, index=False, encoding='utf-8-sig')
    
    elapsed = time.time() - start_time
    print("\n" + "="*60)
    print(f"‚úÖ Scan complete. Report: {OUTPUT_FILE}")
    print(f"Total unique vulnerabilities reported: {len(df)}")
    print(f"Time taken: {elapsed//60:.0f}m {elapsed%60:.0f}s")
    if not df.empty:
        print(f"  From NVD: {len(df[df['Source'] == 'NVD'])}")
        print(f"  From Vulners: {len(df[df['Source'] == 'Vulners'])}")
        print(f"  From CVEDetails: {len(df[df['Source'] == 'CVEDetails'])}")
        print(f"Software vulns: {len(df[df['Type'] == 'Software'])}")
        print(f"Port/Service vulns: {len(df[df['Type'] == 'Port/Service'])}")
        print(f"Known Exploited (CISA KEV): {len(df[df['Exploited'] == 'Yes'])}")
    print("="*60)

if __name__ == "__main__":
    if not SOFTWARE_LIST:
         print("ERROR: SOFTWARE_LIST is empty.")
    else:
        main()