import requests
import pandas as pd
import time
import re
from datetime import datetime, timedelta

# List of Windows services and processes to monitor
WINDOWS_SERVICES_PROCESSES = [
    'svchost.exe', 'lsass.exe', 'wininit.exe', 'services.exe', 'lsm.exe',
    'spoolsv.exe', 'taskhost.exe', 'dllhost.exe', 'csrss.exe', 'winlogon.exe',
    'smss.exe', 'explorer.exe', 'wmiprvse.exe', 'msdtc.exe', 'dwm.exe',
    'svchost', 'service host', 'service_host',
    'Background Intelligent Transfer Service', 'BITS',
    'Cryptographic Services', 'CryptSvc',
    'DHCP Client', 'Dhcp',
    'DNS Client', 'Dnscache',
    'Event Log', 'EventLog',
    'Group Policy Client', 'gpsvc',
    'Network Connections', 'Netman',
    'Plug and Play', 'PlugPlay',
    'Print Spooler', 'Spooler',
    'Remote Procedure Call', 'RpcSs',
    'Security Accounts Manager', 'SamSs',
    'Server', 'LanmanServer',
    'Task Scheduler', 'Schedule',
    'Windows Audio', 'AudioSrv',
    'Windows Defender', 'WinDefend',
    'Windows Firewall', 'MpsSvc',
    'Windows Management Instrumentation', 'Winmgmt',
    'Windows Update', 'wuauserv',
    'ctfmon.exe', 'rundll32.exe', 'msiexec.exe', 'conhost.exe', 'SearchIndexer.exe',
    'WmiPrvSE.exe', 'TrustedInstaller.exe'
]

def get_date_range():
    """Get date range for 2024-01-01 to today"""
    start_date = "2024-01-01T00:00:00.000"
    end_date = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.000')
    return start_date, end_date

def fetch_cisa_kev():
    """Fetch CISA's Known Exploited Vulnerabilities catalog"""
    print("Fetching CISA KEV catalog...")
    try:
        response = requests.get("https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json", 
                               timeout=15)
        response.raise_for_status()
        return response.json().get('vulnerabilities', [])
    except Exception as e:
        print(f"⚠️ Failed to fetch CISA KEV: {str(e)}")
        return []

def get_service_mitigation(service_name, cve_id, cisa_kev):
    """Generate mitigation guidance for specific services"""
    # Check CISA recommendations first
    for vuln in cisa_kev:
        if vuln.get('cveID') == cve_id:
            return vuln.get('requiredAction', 'Apply vendor updates immediately')
    
    # Service-specific guidance
    mitigations = {
        'print spooler': [
            "Disable Print Spooler service if not needed",
            "Restrict access to spooler directories",
            "Apply latest security updates"
        ],
        'windows update': [
            "Ensure automatic updates are enabled",
            "Verify update integrity with hashes",
            "Monitor for unusual update behavior"
        ],
        'windows defender': [
            "Keep antivirus signatures updated",
            "Enable tamper protection",
            "Run regular full system scans"
        ],
        'remote procedure call': [
            "Restrict RPC access via firewall",
            "Disable unnecessary RPC endpoints",
            "Enable RPC authentication"
        ],
        'task scheduler': [
            "Audit scheduled tasks regularly",
            "Restrict task creation privileges",
            "Monitor task execution logs"
        ],
        'default': [
            "Stop and disable the service if not required",
            "Apply all security updates for the service",
            "Restrict service permissions using ACLs",
            "Monitor service execution and resource usage"
        ]
    }
    
    service_lower = service_name.lower()
    for key in mitigations:
        if key in service_lower:
            return "\n".join(mitigations[key])
    
    return "\n".join(mitigations['default'])

def identify_affected_services(description):
    """Identify Windows services/processes mentioned in vulnerability description"""
    if not description:
        return []
    
    desc_lower = description.lower()
    affected = []
    
    # Check for service/process names
    for service in WINDOWS_SERVICES_PROCESSES:
        service_lower = service.lower()
        if service_lower in desc_lower:
            # Prioritize exact matches
            if re.search(rf'\b{re.escape(service_lower)}\b', desc_lower):
                affected.append(service)
    
    # Special case for service abbreviations
    service_mappings = {
        'bits': 'Background Intelligent Transfer Service',
        'cryptsvc': 'Cryptographic Services',
        'dhcp': 'DHCP Client',
        'dnscache': 'DNS Client',
        'eventlog': 'Event Log',
        'gpsvc': 'Group Policy Client',
        'netman': 'Network Connections',
        'plugplay': 'Plug and Play',
        'spooler': 'Print Spooler',
        'rpcss': 'Remote Procedure Call',
        'sams': 'Security Accounts Manager',
        'lanmanserver': 'Server',
        'schedule': 'Task Scheduler',
        'audiosrv': 'Windows Audio',
        'windefend': 'Windows Defender',
        'mpssvc': 'Windows Firewall',
        'winmgmt': 'Windows Management Instrumentation',
        'wuauserv': 'Windows Update'
    }
    
    for abbr, full_name in service_mappings.items():
        if abbr in desc_lower and full_name not in affected:
            affected.append(full_name)
    
    return list(set(affected))

def get_cvss_score(cve):
    """Safely extract CVSS score"""
    try:
        metrics = cve.get('metrics', {})
        if 'cvssMetricV3' in metrics:
            return metrics['cvssMetricV3'][0]['cvssData']['baseScore']
        elif 'cvssMetricV2' in metrics:
            return metrics['cvssMetricV2'][0]['cvssData']['baseScore']
    except (KeyError, IndexError, TypeError):
        pass
    return "N/A"

def fetch_nvd_batch(start_index, start_date, end_date, results_per_page=2000):
    """Fetch vulnerabilities from NVD API within date range"""
    try:
        url = (f"https://services.nvd.nist.gov/rest/json/cves/2.0?"
               f"pubStartDate={start_date}&pubEndDate={end_date}&"
               f"keywordSearch=windows&startIndex={start_index}&resultsPerPage={results_per_page}")
        
        headers = {"User-Agent": "Windows-Service-Vuln-Scanner/1.0"}
        response = requests.get(url, headers=headers, timeout=30)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"⚠️ NVD API error: {str(e)}")
        return None

def process_vulnerabilities(data, cisa_kev):
    """Process vulnerabilities and extract service-related ones"""
    vuln_list = []
    if not data or 'vulnerabilities' not in data:
        return vuln_list
    
    for item in data['vulnerabilities']:
        try:
            cve = item.get('cve', {})
            cve_id = cve.get('id', '')
            descriptions = cve.get('descriptions', [])
            description = next((d['value'] for d in descriptions if d['lang'] == 'en'), '')
            
            # Identify affected services/processes
            affected_services = identify_affected_services(description)
            if not affected_services:
                continue
                
            # Get primary service for mitigation
            primary_service = affected_services[0] if affected_services else "Windows Service"
            
            # Get mitigation guidance
            mitigation = get_service_mitigation(primary_service, cve_id, cisa_kev)
            
            vuln_list.append({
                'CVE': cve_id,
                'Published': cve.get('published', 'N/A'),
                'Vendor': cve.get('sourceIdentifier', 'N/A'),
                'CVSS': get_cvss_score(cve),
                'AffectedServices': "; ".join(affected_services),
                'PrimaryService': primary_service,
                'Description': description,
                'Mitigation': mitigation,
                'LastUpdated': datetime.utcnow().strftime('%Y-%m-%d')
            })
        except Exception as e:
            print(f"⚠️ Error processing {cve_id}: {str(e)}")
    
    return vuln_list

def main():
    # Get date range
    start_date, end_date = get_date_range()
    print(f"Collecting vulnerabilities from {start_date} to {end_date}")
    
    # Fetch CISA KEV catalog
    cisa_kev = fetch_cisa_kev()
    print(f"Loaded {len(cisa_kev)} CISA KEV records")
    
    # Vulnerability collection parameters
    all_vulns = []
    target_count = 10000
    batch_size = 2000
    max_retries = 3
    
    print("\nStarting vulnerability collection for Windows services...")
    print(f"Monitoring {len(WINDOWS_SERVICES_PROCESSES)} services/processes")
    start_time = time.time()
    batch_count = 0
    total_results = 0
    
    while len(all_vulns) < target_count:
        batch_count += 1
        start_index = len(all_vulns)
        retries = 0
        success = False
        batch_vulns = []
        
        while retries < max_retries and not success:
            try:
                # Fetch batch from NVD
                data = fetch_nvd_batch(start_index, start_date, end_date, batch_size)
                if not data:
                    raise ValueError("Empty API response")
                
                # Get total results available
                if total_results == 0:
                    total_results = data.get('totalResults', 0)
                    print(f"Total vulnerabilities in date range: {total_results}")
                    if total_results == 0:
                        break
                
                # Process vulnerabilities
                batch_vulns = process_vulnerabilities(data, cisa_kev)
                all_vulns.extend(batch_vulns)
                success = True
                
                # Progress tracking
                elapsed = time.time() - start_time
                print(f"Batch {batch_count}: Processed {len(batch_vulns)} service vulns | "
                      f"Total: {len(all_vulns)}/{min(target_count, total_results)} | "
                      f"Elapsed: {elapsed//60:.0f}m {elapsed%60:.0f}s")
                
            except Exception as e:
                retries += 1
                wait = 10 * retries
                print(f"Error: {e}. Retry {retries}/{max_retries} in {wait}s")
                time.sleep(wait)
        
        if not success:
            print(f"⚠️ Failed to process batch {batch_count}")
            if batch_count > 10:  # Prevent infinite loops
                break
        
        # Check if we've reached target or end of results
        if len(all_vulns) >= target_count or len(all_vulns) >= total_results:
            break
            
        # Respect NVD rate limits
        time.sleep(6)
    
    # Trim to target count
    final_vulns = all_vulns[:target_count]
    
    # Save results
    if final_vulns:
        df = pd.DataFrame(final_vulns)
        filename = f"windows_service_vulns_2024_{len(df)}_{datetime.utcnow().strftime('%Y%m%d')}.csv"
        df.to_csv(filename, index=False)
        
        print("\n" + "="*60)
        print(f"✅ Saved {len(df)} Windows service vulnerabilities to {filename}")
        print(f"Publication Period: {start_date} to {end_date}")
        print(f"Top Services: {df['PrimaryService'].value_counts().head(10).to_dict()}")
        print(f"CVSS Score Distribution: {df['CVSS'].value_counts().head(5).to_dict()}")
        print("="*60)
    else:
        print("No service vulnerabilities found in the specified date range!")

if __name__ == "__main__":
    main()